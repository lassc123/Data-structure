# 数据结构——二叉树

## 1.树的概念及结构

### 1.1树的概念![_10450](https://gitee.com/lassc123/imgs/raw/master/_10450.png)

==树是一种非线性的数据结构，==它是由n个有限结点组成的一个具有层次关系的集合。

•树有一个**特殊的节点**，**称为根节点**，它没有前驱节点（没有父节点）。

![image-20240514175216146](https://gitee.com/lassc123/imgs/raw/master/image-20240514175216146.png)

•树是递归定义的

![image-20240514175343258](https://gitee.com/lassc123/imgs/raw/master/image-20240514175343258.png)

注意：**树形结构中，子树之间不能有交集，否则就不是树形结构**

### 1.2 树的相关概念

![image-20240514175628108](https://gitee.com/lassc123/imgs/raw/master/image-20240514175628108.png)

### 1.3 树的表示

树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，**既然保存值域，也要保存结点和结点之间的关系**。

实际中树有很多种表示方式如：

![image-20240514175834391](https://gitee.com/lassc123/imgs/raw/master/image-20240514175834391.png)

其中**左孩子右兄弟表示法**是目前树型结构的最优表示，极大简化了树的结构。

```c
typedef int DataType;
struct Node
{
 struct Node* _firstChild1; // 第一个孩子结点
 struct Node* _pNextBrother; // 指向其下一个兄弟结点
 DataType _data; // 结点中的数据域
};
```

![image-20240514180210678](https://gitee.com/lassc123/imgs/raw/master/image-20240514180210678.png)

### 1.4树在实际中的运用（用于文件系统的目录树结构）

![image-20240514180310548](https://gitee.com/lassc123/imgs/raw/master/image-20240514180310548.png)

## 2.二叉树概念及结构

### 2.1二叉树概念

一棵二叉树是结点的一个有限集合，该集合:

1. 或者为空 

2.  由一个根节点加上两棵别称为左子树和右子树的二叉树组成 

   ![image-20240514180532254](https://gitee.com/lassc123/imgs/raw/master/image-20240514180532254.png)

从上图可以看出：

1. ==二叉树不存在度大于2的结点==
2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树

注意：**对于任意的二叉树都是由以下几种情况复合而成的**：

![image-20240514180710928](https://gitee.com/lassc123/imgs/raw/master/image-20240514180710928.png)

### 2.3特殊的二叉树

1. ==满二叉树==：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是 说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。**==（每一层都是满的）==**
2. ==完全二叉树==：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对 应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。（**共h层，前h-1层都是满的， 最后一层可以 不满，但是从 左到右是连续的。**）

![image-20240514182016760](https://gitee.com/lassc123/imgs/raw/master/image-20240514182016760.png)

### 2.4二叉树的性质

![image-20240514182512984](https://gitee.com/lassc123/imgs/raw/master/image-20240514182512984.png)

### 2.5 二叉树的存储结构

二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。

1.顺序存储

​	顺序结构存储就是使用**数组来存储**，一般使用数组**只适合表示完全二叉树**，**因为不是完全二叉树会有空间的浪费**。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。**二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。**

![image-20240514182808054](https://gitee.com/lassc123/imgs/raw/master/image-20240514182808054.png)

![image-20240514182829467](https://gitee.com/lassc123/imgs/raw/master/image-20240514182829467.png)

2.链式结构

二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。

![image-20240514182926410](https://gitee.com/lassc123/imgs/raw/master/image-20240514182926410.png)

```c
 typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{
 struct BinTreeNode* _pLeft; // 指向当前节点左孩子
 struct BinTreeNode* _pRight; // 指向当前节点右孩子
 BTDataType _data; // 当前节点值域
}
// 三叉链
struct BinaryTreeNode
{
 struct BinTreeNode* _pParent; // 指向当前节点的双亲
 struct BinTreeNode* _pLeft; // 指向当前节点左孩子
 struct BinTreeNode* _pRight; // 指向当前节点右孩子
 BTDataType _data; // 当前节点值域
}；
```

## 3.二叉树（堆）的顺序结构及实现

### 3.1二叉树（堆）的顺序结构

普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。**现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。**

![image-20240514183305459](https://gitee.com/lassc123/imgs/raw/master/image-20240514183305459.png)

### 3.2堆的概念及结构

![image-20240514183356261](https://gitee.com/lassc123/imgs/raw/master/image-20240514183356261.png)

![image-20240514183414387](https://gitee.com/lassc123/imgs/raw/master/image-20240514183414387.png)

#### 3.2.1堆的创建

下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算 法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢？这里我们从倒数的第一个非叶子节点的 子树开始调整，一直调整到根节点的树，就可以调整成堆。

```c
int a[] = {1,5,3,8,7,6}; 
```

![image-20240514183713035](https://gitee.com/lassc123/imgs/raw/master/image-20240514183713035.png)

这其中设计了堆中的向上调整算法：

其具体实行如下：

```c
void AdjustUP(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	//while (parent >= 0)
	while(child > 0)
	{
		if (a[child] > a[parent])
		{
			HPDataType tmp = a[child];
			a[child] = a[parent];
			a[parent] = tmp;

			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}
```

```c
//Heap.h
#pragma once
#include<stdio.h>
#include<stdbool.h>
#include<stdlib.h>
#include<assert.h>
typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;//插入的数据个数
	int capacity;//总容量
}Heap;

void HeapInit(Heap* php);
void HeapDestroy(Heap* php);
void HeapPush(Heap* php, HPDataType x);
// 堆的删除
void HeapPop(Heap* hp);
// 取堆顶的数据
HPDataType HeapTop(Heap* hp);
// 堆的数据个数
int HeapSize(Heap* hp);
// 堆的判空
bool HeapEmpty(Heap* hp);
void AdjustUp(HPDataType* a, int child);
void AdjustDown(HPDataType* a, int parent, int size);
//Heap.c
#include"Heap.h"
void Swap(HPDataType* a, HPDataType* b)
{
	HPDataType tmp = *a;
	*a = *b;
	*b = tmp;
}
void HeapInit(Heap* php)
{
	assert(php);
	php->a = NULL;
	php->size = php->capacity = 0;
};
void HeapDestroy(Heap* php) 
{
	assert(php);
	free(php->a);
	php->a = NULL;
	php->size = php->capacity = 0;
}
;
void HeapPush(Heap* php, HPDataType x)
{
	assert(php);
	if (php->capacity == php->size)
	{
		int newcapacity = php->capacity == 0 ? 4 : php->capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php->a,newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("malloc failed");
			return;
		}
		php->a = tmp;
		php->capacity = newcapacity;
	}
	php->a[php->size] = x;
	php->size++;
	AdjustUp(php->a, php->size - 1);
};
// 堆的删除
void HeapPop(Heap* hp)
{
	assert(hp);
	assert(!HeapEmpty(hp));
	Swap(&hp->a[0], &hp->a[hp->size - 1]);
	hp->size--;
	AdjustDown(hp->a, 0, hp->size);

};
// 取堆顶的数据
HPDataType HeapTop(Heap* hp)
{
	return hp->a[0];
};
// 堆的数据个数
int HeapSize(Heap* hp)
{
	return hp->size;
};

// 堆的判空
bool HeapEmpty(Heap* hp)
{
	return hp->size == 0;
};
//向上调整
void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	//建小堆
	while (child > 0)
	{
		if (a[child] < a[parent])
		{
			Swap(&a[child], &a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	};
};
void AdjustDown(HPDataType* a, int parent,int size)
{
	int child = parent * 2 + 1;
	
	//小堆
	while (child < size )
	{
		if (child+1<size&&a[child] > a[child + 1])
		{
			child++;
		}
		if (a[parent] > a[child])
		{
			Swap(&a[parent], &a[child]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
};
```

### 3.3堆排序

```c
void HeapSort(int* a, int size)
{
	//建堆
	for (int i = (size - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(a, i, size);
	}
	while (size>1)
	{
		Swap(&a[0], &a[size - 1]);
		AdjustDown(a, 0, size-1);
		size--;

	}
}
```

### 3.4TOPk问题

![image-20240520215708638](https://gitee.com/lassc123/imgs/raw/master/202405202157768.png)

```c
void CreateNDate()
{
	// 造数据
	int n = 10000;
	srand(time(0));
	const char* file = "data.txt";
	FILE* fin = fopen(file, "w");
	if (fin == NULL)
	{
		perror("fopen error");
		return;
	}

	for (size_t i = 0; i < n; ++i)
	{
		int x = rand() % 1000000;
		fprintf(fin, "%d\n", x);
	}

	fclose(fin);
}

void PrintTopK(int k)
{
	const char* file = "data.txt";
	FILE* fout = fopen(file, "r");
	if (fout == NULL)
	{
		perror("fopen error");
		return;
	}

	int* kminheap = (int*)malloc(sizeof(int) * k);
	if (kminheap == NULL)
	{
		perror("malloc error");
		return;
	}

	for (int i = 0; i < k; i++)
	{
		fscanf(fout, "%d", &kminheap[i]);
	}

	// 建小堆
	for (int i = (k-1-1)/2; i >= 0; i--)
	{
		AdjustDown(kminheap, k, i);
	}

	int val = 0;
	while (!feof(fout))
	{
		fscanf(fout, "%d", &val);
		if (val > kminheap[0])
		{
			kminheap[0] = val;
			AdjustDown(kminheap, k, 0);
		}
	}

	for (int i = 0; i < k; i++)
	{
		printf("%d ", kminheap[i]);
	}
	printf("\n");
}
```

## 4.二叉树的遍历

![image-20240520224940432](https://gitee.com/lassc123/imgs/raw/master/202405202249592.png)

•前序

![image-20240520225149349](https://gitee.com/lassc123/imgs/raw/master/202405202251436.png)![image-20240520225243902](https://gitee.com/lassc123/imgs/raw/master/202405202252169.png)

```c
void PrevOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	printf("%d ", root->data);
	PrevOrder(root->left);
	PrevOrder(root->right);
}


```

•中序

![image-20240520225322417](https://gitee.com/lassc123/imgs/raw/master/202405202253619.png)

```c
void InOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	InOrder(root->left);
	printf("%d ", root->data);
	InOrder(root->right);
}

```

## 5.经典二叉树问题

### 问题

```c
// 二叉树节点个数
int BinaryTreeSize(BTNode* root);
// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root);
// 求二叉树的高度
int BTreeHeight(BTNode* root)
// 二叉树第k层节点个数
int BinaryTreeLevelKSize(BTNode* root, int k);
```

### 解答

#### 1. 二叉树节点个数

```c
int BTreeSize(BTNode* root)
{
    //第一种格式
	if (root == NULL)
		return 0;

	return BTreeSize(root->left)
		+ BTreeSize(root->right)
		+ 1;
	//第二种格式
	return root == NULL ? 0 : BTreeSize(root->left)
							+ BTreeSize(root->right) + 1;
}
```

![image-20240521182022436](https://gitee.com/lassc123/imgs/raw/master/202405211820728.png)

分而治之的方法进行拆分子问题和寻找返回条件

#### 2.二叉树叶子节点个数

```c
int BTreeLeafSize(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}

	if (root->left == NULL
		&& root->right == NULL)
	{
		return 1;
	}
	
	return BTreeLeafSize(root->left)
		+ BTreeLeafSize(root->right);

}
```

#### 3.求二叉树的高度

```c
//求二叉树的高度
int BTreeHeight(BTNode* root)
{
	if (root == NULL)
		return 0;

        return BTreeHeight(root->left) >BTreeHeight(root->right)? BTreeHeight(root->left) + 1 : BTreeHeight(root->right) + 1;
}
```

#### 4. 二叉树第k层节点个数

```c
int BTreeLevelKSize(BTNode* root, int k)
{
	assert(k > 0);

	if (root == NULL)
		return 0;

	if (k == 1)
		return 1;

	return BTreeLevelKSize(root->left, k - 1)
		+ BTreeLevelKSize(root->right, k - 1);
}
```

![image-20240521182755203](https://gitee.com/lassc123/imgs/raw/master/202405211827388.png)
